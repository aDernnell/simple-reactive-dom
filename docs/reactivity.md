Reactivity
=========

This section describes how reactivity is implemented, allowing node issued from templates to automatically update when their underlying data changes.

## Description

Reactivity is based on the concept of [stores](/stores). The framework provides a way to embed these stores into HTML templates, allowing the DOM to automatically update when the store values change.

The reactivity mechanism is set up when a template is converted to a DOM node with the `node()` function.

There are two modes of operation, dependeing on how the `node()` function is called:
- **direct mode**   
    Every reactive value is handled by a store embedded in the template and embedded dynamic values that are not stores are not reactive.
- **watch mode**    
    A function is used to listen to some stores and when one of them changes, the function is called and the template is re-evaluated, updating the DOM accordingly. It allows to embed dynamic values that are not stores. It is useful for reevaluating embedded expressions for example.

These modes can be used together in a single template, allowing for both direct store updates and reactive expressions.

## Exemples

```js
// Direct mode: store is embedded directly in the template
const countStore = store(0);
const directNode = node`<button>Count: ${countStore}</button>`;
directNode.addEventListener('click', () => {
  countStore.update(value => value + 1); // Triggers Node update
});

// Watch mode: use a function to watch stores and re-render
// the watch function register a store to be subscribed to and returns the store value
const items = writable(['Item 1', 'Item 2', 'Item 3']);
const watchNode = node(watch => html`
    <ul>
        ${watch(items).forEach(item => html`<li>${item}</li>`)}
    </ul>
`);
items.update(current => [...current, 'Item 4']); // Triggers Node update

// Watch mode can alo be used to listen to a store whose value is not part of the template
const count = 0;
const trigger = writable({});
const watchNode2 = node(watch => {
  watch(trigger);
  return html`<div>Expression result: ${count % 2 == 0 ? 'Count is even' : 'Count is Odd'}</div>`;
});
// Can also use a comma operator (,) to be more concise
const watchNode3 = node(watch => (watch(trigger), html`<div>Expression result: ${count > 10 ? 'Count is > 10' : 'Count is < 10'}</div>`));

count = count + 1; // Does not trigger Node update
trigger.set({}); // Triggers Node update

// Direct and watch modes can be used together
const combinedNode = node(watch => (watch(trigger), html`
    <div>
        <span>Count: ${count}</span>
    </div>
`));
```

## Optimisations

The framework try to update the DOM as efficiently as possible by minimizing the number of changes made to the DOM tree.
There are two main strategies for this:
- **Granularity of updates**
- **Batching updates**

### Granularity of updates

The reactivity system determines the smallest part of the DOM that needs to be updated based on where the reactive value is located in the template. This means that only the necessary parts of the DOM are updated, rather than the entire node.

The granularity of the DOM update depends on where the substitution occurs in the template:

| Reactive value location   | What is updated on reactive value change                                 |
|---------------------------------|----------------------------------------------------|
| Inside orphan Text node                | Whole text content of the node         |
| Inside Attribute                       | Whole attribute value                 |
| Inside child Text node         | Node generated by the substitution |

Thus, if two stores are embedded in a child Text node, only the text content associated to the store value is updated when one of the stores changes, rather than the entire node :
```js
const store1 = store('Hello');
const store2 = store('World');
const node = node`<span>${store1} ${store2}</span>`;
store1.set('Hi'); // Only the Text node 'Hello' is replaced, not the whole span !
```
This is possible because the generated Node Tree is as follow : `Span( Text('Hello'), Text(' '), Text('World') )`

In a same way when a template is reevaluated in watch mode, only the parts of the DOM that are affected by the changes in the template are updated, rather than the entire node.

### Batching updates

DOM updates are optimized by batching them when possible, reducing the number of reflows and repaints in the browser. This is controlled by the `DomUpdateMode` option in the `node()` function.

When set to `BATCHED` (default), updates are queued and applied asynchronously in a [microtask](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide), allowing multiple updates to be processed together. See [Debouncer section](/debouncer) for more details.

When set to `EAGER`, updates are applied synchronously, which can be useful for immediate feedback but may lead to performance issues if many updates occur in quick succession.

Same mecanism is used in watch mode, where watched stores updates are batched and applied in a microtask by default, allowing for efficient updates when multiple stores change.

## API Reference

### Types

<big>**DomUpdateMode**</big>

Enum. Controls how DOM updates are scheduled.

_Values:_
- `EAGER`  
  Updates are applied synchronously.
- `BATCHED`  
  Updates are queued and applied asynchronously in a microtask. See [Debouncer section](/debouncer).

---

<big>**DirectOptions**</big>

Options for direct node creation.

_Properties:_
- `serializer?: (value: any, context?: BindingContext, key?: string) => any`  
  Function to serialize values. See [Serialization section](/templating#Serialization).
- `updateDomMode?: DomUpdateMode`  
  DOM update mode.

---

<big>**WatcherOptions**</big> (extends `DirectOptions`)

Options for watcher mode.

_Properties:_
- `debounceWatches?: boolean` â€” Whether to debounce store updates.

---

<big>**Watcher**</big>

A function: `<T>(store: Readable<T>) => T`

---

### Functions

<big>**node**(template: HtmlLiterals, options?: DirectOptions): Node</big>  
<big>**node**(fn: (watch: Watcher) => HtmlLiterals, options?: WatcherOptions): Node</big>

Transforms a template or a function returning a template into an HTML node and implements reactivity. 
- In direct mode, takes the result of a tag function, aka `HtmlLiterals`, and returns a DOM node.
- In watcher mode, takes a function that returns an `HtmlLiterals` object and automatically updates the node when watched stores change.

_Options:_
`DirectOptions` or `WatcherOptions`, depending on the mode.